package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/jitin-nhz/contextpilot/internal/analyzer"
	"github.com/jitin-nhz/contextpilot/internal/decisions"
)

// Generator creates context files from analysis
type Generator struct {
	analysis *analyzer.Analysis
	rootPath string
}

// New creates a new Generator
func New(analysis *analyzer.Analysis, rootPath string) *Generator {
	return &Generator{
		analysis: analysis,
		rootPath: rootPath,
	}
}

// GenerateAll creates all context files
func (g *Generator) GenerateAll() error {
	if err := g.GenerateCursorRules(); err != nil {
		return fmt.Errorf("failed to generate .cursorrules: %w", err)
	}

	if err := g.GenerateClaudeMD(); err != nil {
		return fmt.Errorf("failed to generate CLAUDE.md: %w", err)
	}

	if err := g.GenerateCopilotInstructions(); err != nil {
		return fmt.Errorf("failed to generate copilot-instructions.md: %w", err)
	}

	if err := g.GenerateConfig(); err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}

	return nil
}

// GenerateCursorRules creates .cursorrules file
func (g *Generator) GenerateCursorRules() error {
	content := g.renderCursorRules()
	return os.WriteFile(filepath.Join(g.rootPath, ".cursorrules"), []byte(content), 0644)
}

// GenerateClaudeMD creates CLAUDE.md file
func (g *Generator) GenerateClaudeMD() error {
	content := g.renderClaudeMD()
	return os.WriteFile(filepath.Join(g.rootPath, "CLAUDE.md"), []byte(content), 0644)
}

// GenerateCopilotInstructions creates .github/copilot-instructions.md
func (g *Generator) GenerateCopilotInstructions() error {
	githubDir := filepath.Join(g.rootPath, ".github")
	if err := os.MkdirAll(githubDir, 0755); err != nil {
		return err
	}
	content := g.renderCopilotInstructions()
	return os.WriteFile(filepath.Join(githubDir, "copilot-instructions.md"), []byte(content), 0644)
}

// GenerateConfig creates .contextpilot/config.yaml
func (g *Generator) GenerateConfig() error {
	configDir := filepath.Join(g.rootPath, ".contextpilot")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return err
	}
	content := g.renderConfig()
	return os.WriteFile(filepath.Join(configDir, "config.yaml"), []byte(content), 0644)
}

// Preview returns all generated content without writing files
func (g *Generator) Preview() map[string]string {
	return map[string]string{
		".cursorrules":                    g.renderCursorRules(),
		"CLAUDE.md":                       g.renderClaudeMD(),
		".github/copilot-instructions.md": g.renderCopilotInstructions(),
		".contextpilot/config.yaml":       g.renderConfig(),
	}
}

func (g *Generator) renderCursorRules() string {
	tmpl := `# Project Context for Cursor
# Generated by ContextPilot (contextpilot.dev)
# Last updated: {{.Date}}

## Tech Stack
{{- if .Framework}}
- **Framework:** {{.Framework.Name}}{{if .Framework.Version}} {{.Framework.Version}}{{end}}
{{- end}}
{{- if .Languages}}
- **Languages:** {{.LanguagesList}}
{{- end}}
{{- if .Packages.Manager}}
- **Package Manager:** {{.Packages.Manager}}
{{- end}}
{{- if .Patterns.ORM}}
- **Database/ORM:** {{.Patterns.ORM}}
{{- end}}
{{- if .Patterns.Styling}}
- **Styling:** {{.Patterns.Styling}}
{{- end}}
{{- if .Patterns.TestFramework}}
- **Testing:** {{.Patterns.TestFramework}}
{{- end}}
{{- if .Patterns.StateManagement}}
- **State Management:** {{.Patterns.StateManagement}}
{{- end}}

## Project Structure
- **Type:** {{.Structure.Type}}
{{- if .Structure.SrcDir}}
- **Source Directory:** {{.Structure.SrcDir}}/
{{- end}}
{{- if .Structure.Folders}}
- **Key Folders:** {{.FoldersList}}
{{- end}}
{{- if .Structure.EntryPoint}}
- **Entry Point:** {{.Structure.EntryPoint}}
{{- end}}

## Coding Conventions
{{- if .Patterns.NamingConvention}}
- **Naming:** {{.Patterns.NamingConvention}}
{{- end}}
{{- if .Patterns.ExportStyle}}
- **Exports:** {{.Patterns.ExportStyle}}
{{- end}}
{{- if .Patterns.Linter}}
- **Linter:** {{.Patterns.Linter}}
{{- end}}
{{- if .Patterns.Formatter}}
- **Formatter:** {{.Patterns.Formatter}}
{{- end}}

## Guidelines for AI
1. Follow the existing code style and patterns in this project
2. Use the detected tech stack when generating code
3. Place new files in the appropriate directories based on project structure
4. Follow the naming conventions used in this codebase
{{- if .Patterns.TestFramework}}
5. Write tests using {{.Patterns.TestFramework}}
{{- end}}

## Decisions
{{- if .HasDecisions}}
{{- range .Decisions}}
- **{{.Date}}:** {{.Text}}
{{- end}}
{{- else}}
<!-- Add architectural decisions with: contextpilot decision "Your decision here" -->
{{- end}}

---
*Managed by [ContextPilot](https://contextpilot.dev) • Run 'contextpilot sync' to update*
`
	return g.executeTemplate(tmpl)
}

func (g *Generator) renderClaudeMD() string {
	tmpl := `# CLAUDE.md — AI Context for Claude Code
# Generated by ContextPilot (contextpilot.dev)
# Last updated: {{.Date}}

## About This Project

This project uses:
{{- if .Framework}}
- **{{.Framework.Name}}**{{if .Framework.Version}} ({{.Framework.Version}}){{end}} as the main framework
{{- end}}
{{- range .Languages}}
- **{{.Name}}** ({{.FileCount}} files, {{printf "%.0f" .Percentage}}%)
{{- end}}

## Quick Commands
` + "```" + `bash
# Common commands (update based on your project)
{{- if eq .Packages.Manager "npm"}}
npm install    # Install dependencies
npm run dev    # Start development server
npm test       # Run tests
npm run build  # Build for production
{{- else if eq .Packages.Manager "go"}}
go build       # Build the project
go test ./...  # Run all tests
go run .       # Run the project
{{- else if or (eq .Packages.Manager "pip") (eq .Packages.Manager "poetry/pip")}}
pip install -r requirements.txt  # Install dependencies
python main.py                   # Run the project
pytest                           # Run tests
{{- else}}
# Add your project's common commands here
{{- end}}
` + "```" + `

## Project Structure
{{- if .Structure.Folders}}

Key directories:
{{- range .Structure.Folders}}
- ` + "`" + `{{.}}/` + "`" + `
{{- end}}
{{- end}}

## Coding Conventions

When writing code for this project:

{{- if .Patterns.NamingConvention}}
- Use **{{.Patterns.NamingConvention}}** naming convention
{{- end}}
{{- if .Patterns.ExportStyle}}
- Use **{{.Patterns.ExportStyle}}** exports
{{- end}}
{{- if .Patterns.Styling}}
- Style with **{{.Patterns.Styling}}**
{{- end}}
{{- if .Patterns.ORM}}
- Database access via **{{.Patterns.ORM}}**
{{- end}}
{{- if .Patterns.TestFramework}}
- Write tests with **{{.Patterns.TestFramework}}**
{{- end}}

## When I Ask You To...

- **"Add a new feature"** → Follow existing patterns in the codebase
- **"Write tests"** → Use {{if .Patterns.TestFramework}}{{.Patterns.TestFramework}}{{else}}the project's testing framework{{end}}
- **"Refactor"** → Maintain existing code style and conventions

## Decisions
{{- if .HasDecisions}}

Key architectural decisions for this project:
{{- range .Decisions}}
- **{{.Date}}:** {{.Text}}
{{- end}}
{{- else}}

<!-- Add new decisions with: contextpilot decision "Your decision here" -->
{{- end}}

---
*Managed by [ContextPilot](https://contextpilot.dev) • Run 'contextpilot sync' to update*
`
	return g.executeTemplate(tmpl)
}

func (g *Generator) renderCopilotInstructions() string {
	tmpl := `# GitHub Copilot Instructions
# Generated by ContextPilot (contextpilot.dev)
# Last updated: {{.Date}}

## Project Overview
{{- if .Framework}}
This is a **{{.Framework.Name}}** project{{if .Framework.Version}} ({{.Framework.Version}}){{end}}.
{{- else}}
This is a **{{.PrimaryLanguage}}** project.
{{- end}}

## Tech Stack
{{- if .Languages}}
- Languages: {{.LanguagesList}}
{{- end}}
{{- if .Patterns.ORM}}
- Database: {{.Patterns.ORM}}
{{- end}}
{{- if .Patterns.Styling}}
- Styling: {{.Patterns.Styling}}
{{- end}}
{{- if .Patterns.TestFramework}}
- Testing: {{.Patterns.TestFramework}}
{{- end}}

## Coding Guidelines

### Naming Conventions
{{- if .Patterns.NamingConvention}}
Use {{.Patterns.NamingConvention}} for variable and function names.
{{- end}}

### Code Style
{{- if .Patterns.Linter}}
This project uses {{.Patterns.Linter}} for linting.
{{- end}}
{{- if .Patterns.Formatter}}
This project uses {{.Patterns.Formatter}} for formatting.
{{- end}}

### Project Structure
{{- if .Structure.Folders}}
Key directories: {{.FoldersList}}
{{- end}}

---
*Managed by [ContextPilot](https://contextpilot.dev)*
`
	return g.executeTemplate(tmpl)
}

func (g *Generator) renderConfig() string {
	return fmt.Sprintf(`# ContextPilot Configuration
# Generated: %s

version: 1
lastSync: %s

# Files to generate
outputs:
  - .cursorrules
  - CLAUDE.md
  - .github/copilot-instructions.md

# Directories to ignore during analysis
ignore:
  - node_modules
  - vendor
  - .git
  - dist
  - build
  - __pycache__

# Custom context to include (add your own!)
# customContext:
#   - "We use feature branches and squash merges"
#   - "All PRs need 2 approvals"
`, time.Now().Format("2006-01-02"), time.Now().Format(time.RFC3339))
}

func (g *Generator) executeTemplate(tmplStr string) string {
	// Get decisions
	decMgr := decisions.New(g.rootPath)
	decisionsList, _ := decMgr.List()
	
	// Prepare template data
	data := struct {
		*analyzer.Analysis
		Date            string
		LanguagesList   string
		FoldersList     string
		PrimaryLanguage string
		Decisions       []decisions.Decision
		HasDecisions    bool
	}{
		Analysis:        g.analysis,
		Date:            time.Now().Format("2006-01-02"),
		LanguagesList:   g.languagesList(),
		FoldersList:     strings.Join(g.analysis.Structure.Folders, ", "),
		PrimaryLanguage: g.primaryLanguage(),
		Decisions:       decisionsList,
		HasDecisions:    len(decisionsList) > 0,
	}

	tmpl, err := template.New("context").Parse(tmplStr)
	if err != nil {
		return fmt.Sprintf("Template error: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Sprintf("Template execution error: %v", err)
	}

	return buf.String()
}

func (g *Generator) languagesList() string {
	names := make([]string, 0, len(g.analysis.Languages))
	for _, lang := range g.analysis.Languages {
		names = append(names, lang.Name)
	}
	return strings.Join(names, ", ")
}

func (g *Generator) primaryLanguage() string {
	if len(g.analysis.Languages) > 0 {
		return g.analysis.Languages[0].Name
	}
	return "Unknown"
}
